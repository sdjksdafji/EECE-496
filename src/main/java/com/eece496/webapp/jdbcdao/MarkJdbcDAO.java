package com.eece496.webapp.jdbcdao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import com.eece496.webapp.dao.MarkDAO;
import com.eece496.webapp.jdbcdao.mapper.MarkMapper;
import com.eece496.webapp.pojo.Mark;
import com.eece496.webapp.pojo.Student;
import com.eece496.webapp.pojo.Subsection;

@Named("markDao")
public class MarkJdbcDAO implements MarkDAO {
	
	@Inject
	private JdbcTemplate jdbcTemplate;
	
	@Inject
	private MarkMapper markMapper;

	@Override
	public boolean addMark(Mark mark, int studentId, int holddateId) {
		final String INSERT_SQL = "insert into marks (mark, student_id, hold_date_id, is_individual_mark) values(?, ?, ?, ?)";
		long autoGeneratedKey = -1;
		final Mark _mark = mark;
		final int _studentId = studentId;
		final int _holddateId = holddateId;
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			this.jdbcTemplate.update(new PreparedStatementCreator() {
				public PreparedStatement createPreparedStatement(
						Connection connection) throws SQLException {
					PreparedStatement ps = connection.prepareStatement(
							INSERT_SQL, new String[] { "id" });
					ps.setInt(1, _mark.getMark());
					ps.setInt(2, _studentId);
					ps.setInt(3, _holddateId);
					ps.setBoolean(4, _mark.isIndividualMark());
					return ps;
				}
			}, keyHolder);
			autoGeneratedKey=  (Long) keyHolder.getKey();
		} catch (Exception ex) {
			ex.printStackTrace();
			return false;
		}
		_mark.setId((int)autoGeneratedKey);
		return true;
	}
	

	@Override
	public boolean deleteMark(int markId) {
		final String DELETE_SQL = "delete from marks where id = ?";
		try {
			this.jdbcTemplate.update(DELETE_SQL, markId);
		} catch (Exception ex) {
			ex.printStackTrace();
			return false;
		}
		return true;
	}

	@Override
	public Mark getIndividualMark(int holdDateId) {
		Mark mark = null;
		final String SQL_QUERY = "select * from marks where hold_date_id = ? AND is_individual_mark = 1";
		try {
			mark = this.jdbcTemplate.queryForObject(SQL_QUERY,
					new Object[] { holdDateId }, this.markMapper);
		} catch (Exception sqlEx) {

		}
		return mark;
	}

	@Override
	public List<Mark> getGroupMarkOfHolddate(int holddateId) {
		List<Mark> markList = new ArrayList<Mark>();
		final String SQL_QUERY = "select * from marks where hold_date_id = ? and is_individual_mark = 0";
		try {
			markList = this.jdbcTemplate.query(SQL_QUERY,
					new Object[] { holddateId }, this.markMapper);
		} catch (Exception sqlEx) {

		}
		return markList;
	}


	@Override
	public boolean updateMark(Mark mark) {
		final String SQL_QUERY = "update marks set mark = ?, student_id = ?, hold_date_id = ?, is_individual_mark = ? where id = ?";
		try {
			this.jdbcTemplate.update(SQL_QUERY,
					mark.getMark(), mark.getStudentId(), mark.getHoldDateId(), mark.isIndividualMark(), mark.getId());
		} catch (Exception sqlEx) {
			return false;
		}
		return true;
	}


	@Override
	public Mark getMarkById(int markId) {
		Mark mark = null;
		final String SQL_QUERY = "select * from marks where id = ?";
		try {
			mark = this.jdbcTemplate.queryForObject(SQL_QUERY,
					new Object[] { markId }, this.markMapper);
		} catch (Exception sqlEx) {
			sqlEx.printStackTrace();
			return null;
		}
		return mark;
	}


	@Override
	public int getAvgMarkOfStudent(int studentId) {
		int avg;
		final String SQL_QUERY = "SELECT avg(mark) FROM `marks` WHERE student_id = ?";
		try {
			avg = this.jdbcTemplate.queryForInt(SQL_QUERY, studentId);
		} catch (Exception sqlEx) {
			sqlEx.printStackTrace();
			return -1;
		}
		return avg;
	}
}
